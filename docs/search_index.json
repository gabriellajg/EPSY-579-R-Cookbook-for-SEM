[["into-to-r.html", "Chapter 2 Into to R 2.1 R as a calculator 2.2 Formal Rules for Indexing Objects in R 2.3 Examples", " Chapter 2 Into to R In this lab, we will learn the basic operations of R. Let’s first meet the commenter in R: #: I am a comment, indicated by a number sign (also called a pound sign, or, a hashtag). 2.1 R as a calculator In many ways, R is just a fancy calculator: 2 + 3 ## [1] 5 To run this command ON A MAC, highlight it and press COMMAND+ENTER. ON A PC, press CTRL+R. If you ‘run’ the comments, it will automatically run the next executable line comments after the command will show in the console as well In R, you can perform: 2 + 1 #addition 7 - 3 #subtraction 2 * 4 #multiplication 8 / 2 #division You can also work with exponents: 4^2 #4 to the 2nd power 4**2 #same thing Square Root: sqrt(16) And perform a variety of other operations. Here’s a helpful table: Arithmetic Operators #===========#==================#===========# # Operator # Meaning # Example # #===========#==================#===========# # + # Addition # 2 + 2 # #-----------#------------------#-----------# # - # Subtraction # 5 - 3 # #-----------#------------------#-----------# # * # Multiplication # 3 * 4 # #-----------#------------------#-----------# # / # Division # 12 / 3 # #-----------#------------------#-----------# # ^ or ** # Power # 3^3; 2**4 # #-----------#------------------#-----------# # sqrt() # square root # sqrt(16) # #-----------#------------------#-----------# # abs() # absolute value # abs(-5) # #-----------#------------------#-----------# Like any calculator, order of operations counts in R: 3*6+5/4 (3*6)+(5/4) #same 3*(6+5)/4 #different 3*((6+5)/4) #same as above Remember PEMDAS? (Parentheses, Exponents, Multiplication, Division, Addition, Subtraction) Given two or more operations in a single expression, PEMDAS tells you the order of the calculation. 2.2 Formal Rules for Indexing Objects in R There are many clever ways to index and retrieve subsets of objects in R, as we shall see, but all of them boil down to 3 formal rules. By supplying a vector of integers indicating the number(s) of the elements/rows/columns to be subsetted. A vector of POSITIVE INTEGERS indicates the elements to be selected. Vectors can be indexed: stringvec &lt;- c(&quot;Chen&quot;, &quot;Julia&quot;, &quot;Lee&quot;, &quot;Mike&quot;, &quot;Winston&quot;, &quot;Coach&quot;) stringvec[c(1,2,3)] A vector of NEGATIVE INTEGERS indicates the elements NOT to be selected (to be removed). stringvec[c(-1,-2,-3)] By supplying a character vector indicating the names() of the elements/rows/columns to be selected. (row/colnames for table objects). By supplying a logical vector of TRUE and FALSE (T and F) of the same length as the vector or dimension to be subsetted. In this case, elements flagged as TRUE will be selected and those flagged as FALSE will be omitted. COROLLARY: A vector may be indexed in any of these three ways OR BY SUPPLYING AS AN INDEX ANY OBJECT OR OPERATION THAT RETURNS ONE OF THESE THREE THINGS. Let us demonstrate each of these things in turn: 2.3 Examples 1a. Positive integers indicating element numbers. stringvec[c(1,3,5)] #Returns 1st, 3rd, and 5th elements 1b. Negative integers indicating element numbers to be omitted: stringvec[-c(2,4,6)] Note that this is because -c(2,4,6) Negates all three numbers. Also note that: stringvec[c(1,-2,3)] Returns an error. this is because selecting certain (positive) numbers already implies omitting others, so the negative integer is confusing and redundant. Character vector corresponding to element names. Let’s give our object some names: names(stringvec) &lt;- paste(&quot;Friend&quot;, 1:length(stringvec), sep=&quot;&quot;) stringvec stringvec[&quot;Friend1&quot;] stringvec[c(&quot;Friend3&quot;,&quot;Friend5&quot;)] stringvec[paste(&quot;Friend&quot;, c(1, 2, 5), sep=&quot;&quot;)] Logical Vector: Let’s say we want to select “Chen”, “Lee”, “Winston”, and “Coach”. stringvec[c(T, F, T, F, T, T)] Now let’s create a vector that stores each character’s gender: gender &lt;- factor(c(1, 2, 1, 2, 1, 1), levels = c(1,2), labels = c(&quot;Male&quot;, &quot;Female&quot;)) Now we can select “Chen”, “Lee”, “Winston”, and “Coach” by simply entering: stringvec[gender == &quot;Male&quot;] Or we could select Julia and Mike using: stringvec[gender == &quot;Female&quot;] We could get even more creative … stringvec[(gender == &quot;Female&quot; | stringvec == &quot;Chen&quot;)] Why do all of these things work and actually return sensible results? It’s because they all return logical vectors of the appropriate length, with #TRUE values in the slots we want. We can demonstrate this by running these commands outside of the braces: gender == &quot;Male&quot; gender == &quot;Female&quot; Even though this is a completely separate variable, these commands return logical vectors of the appropriate length, with TRUE and FALSE values in the appropriate places. (gender == &quot;Female&quot; | stringvec == &quot;Chen&quot;) Here again, same thing. Although different types of objects we will discuss have different numbers of dimensions and different formats, if you remember these THREE WAYS TO SUBSET AN OBJECT (integers = element index, characters = element name, logical = flag element as TRUE), you will be a master at subsetting any object in R. "]]
